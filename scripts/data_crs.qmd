---
title: "data_crs"
format: html
editor: visual
---

```{r load_packages}
source(here::here('scripts', 'library.R'))
```

# Data import

Data is extracted from the OECD platform as text files. There is one text file per year between 2002 and 2022, except for 2002-03 and 2004-05. There are 19 files in total.

```{r data_import}

# create path to folder w/ raw data
# change path accordingly
folder_path <- ("C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\source\\outcome\\crs")
# create list of all files included in the folder
file_list <- list.files(path = folder_path, full.names = TRUE, pattern = '^CRS 2')
# create function to read the csv files
read_clean_and_process <- function(file_path) {
  data <- fread(file_path) |> 
    janitor::clean_names() |> # clean variable names
    mutate_if(is.character, str_trim) # delete white space before/after text
  
  return(data)
}

# apply ad hoc function on all listed csv files in the folder
data_list <- lapply(file_list, read_clean_and_process)
# create a data.table
data_import <- data.table::rbindlist(data_list, fill = T)
```

# Data selection

```{r data_select}

data_select <- data_import |> 
# select variables
    dplyr::select(1:26, 39, 44:54, 57:59, 62:67, 74:77, 78) |>
# delete white space before/after text
    mutate_if(is.character, str_trim)
```

# Data cleaning

## Identification variables

I create four-digit ID variables for both donors and recipients.

```{r id}

# format donor_code values with leading zeros to ensure each value has 4 digits
data_crs <- data_crs |> 
  mutate(
    donor_id = sprintf("%04d", donor_code),
    recipient_id = sprintf("%04d", recipient_code)
    ) |> 
  relocate(donor_id, .after = donor_code) |> 
  relocate(recipient_id, .after = recipient_code)
```

## Cohorts

```{r cohort}

data_crs <- data_crs |> 
  mutate(cohort_donor = min(year), .by = donor_id) |> 
  mutate(cohort_recipient = min(year), .by = recipient_id)
```

## Calibrated sample

We reduce the sample to projects with the following characteristics:

```{r data_calibrated}
data_calibrated <- data_select
```

### Nature of submission

-   **Remove**: (2) Revision, (5) Provisional data, (9) Net disbursements.
-   **Keep**: (1) New activity reported, (3) Previously reported activity (increase/decrease of earlier commitment, disbursement on earlier commitment), (8) Commitment derived from Disbursement, and NAs.

```{r submission}
data_calibrated <- filter(data_calibrated, !initial_report %in% c(2,5,9))
```

### Type of flow

-   **Remove**: non-concessional official & private flows.

-   **Keep**: grants (11) and loans ODA (13).

```{r flow}
data_calibrated <- filter(data_calibrated, flow_code %in% c(11, 13))
```

### Cooperation modalities

-   **Remove**: project observations in provider countries e.g. (E) Scholarships and student costs in donor countries, (G) Administrative costs not included elsewhere, and (H) Other in-donor expenditures.
-   **Keep**: (A) Budget support, (B) Core contributions and pooled programmes and funds, (C) Project-type interventions, (D) Experts and other technical assistance, (F) Debt relief.

```{r modality}
data_calibrated <- filter(data_calibrated, !grepl("^[EGH].*", aid_t) & aid_t != "D01")
```

### Purposes

-   **Remove**: Administrative Costs of Donors (910), Refugees in Donor Countries (930), Promotion of development awareness (99820).

-   **Keep**: all other sectors.

```{r purpose}
data_calibrated <- filter(data_calibrated, !grepl("^(91|93)|99820", purpose_code))
```

### Recipients

-   **Remove**: unspecified, regional.

-   **Keep**: specified countries.

```{r recipient}

# share of total commitments allocated at the regional level
summarize(data_calibrated,
          regional = sum(usd_commitment_defl[grepl("regional", recipient_name)], na.rm = T),
          total = sum(usd_commitment_defl, na.rm = T),
          reg_share_total = regional/total * 100
          )

data_calibrated <- filter(data_calibrated, !grepl('unspecified|regional', recipient_name))
```

## Duplicates

Duplicates are removed.

```{r dupes}
data_clean <- unique(data_calibrated)
```

# Data transformation

## Channel of delivery

### Level consistency

The OECD uses a three-level hierarchical typology for channels of delivery.

Depending of the channel category, the third level includes either the *type* of agency (ex: Pension Funds in Private sector in provider country) or the *name* of a specific agency (ex: African Development Bank in Regional Development Bank).

The name of the agency can also be added manually by the provider, but reporting is inconsistent and reported agencies aren't always included in the OECD's list of ODA-eligible international organisations.

#### Table: Example with the Donor Government group category.

| Code | Level 1 | Code | Level 2 | Code | Level 3 | Reported name |
|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 10000 | Public Sector Institutions | 11000 | Donor Government | 11001 | Central Government | Ex: Ministry Of Employment And Labor, The U.S Department Of Homeland Security, Miscellaneous Suppliers, etc. |
|  |  |  |  | 11002 | Local Government | Ex: Comune Di Reggio Emilia, Local Government, Busan Metropolitan City, etc. |
|  |  |  |  | 11003 | Public corporations | Ex: The Export-Import Bank Of Korea, Kfw, Public Corporations, etc. |
|  |  |  |  | 11004 | Other public entities in donor country | Ex: University Of Trento, Korea Rural Economic Institute, King Salman For Relief And Humanitarian Aid Center |

There are two variables with codes for channel of delivery: `channel_parent_category` (level 1) and `channel_code` (levels 2 and 3).

To help the analysis, I create a unique code variable using the most granular level when both `channel_parent_category` and `channel_code` are provided.

```{r data_channel}

# Create a copy of the data
df <- copy(data_clean)

# Rename columns
setnames(df, old = "parent_channel_code", new = "channel_parent_code")

# Define the columns that match the pattern
channel_cols <- grep("^channel.*name$", names(df), value = TRUE)

# Harmonize style, replace "" by NA, and delete space before/after character string
df[, (channel_cols) := lapply(.SD, function(x) na_if(str_squish(str_to_title(x)), "")),
             .SDcols = channel_cols]

# Create new variable channel_code_unique
df[, channel_code_unique := fifelse(
  rowSums(!is.na(.SD)) == 2,
  do.call(pmax, c(.SD, na.rm = TRUE)),
  NA_real_
), .SDcols = c("channel_code", "channel_parent_code")]

# Relocate channel_code_unique after channel_parent_code
data_channel = df |> relocate(channel_code_unique, .after = channel_parent_code)

```

I also create a variable `channel_level` to specify the level of the most disaggregated channel available.

```{r channel_level}

# Create a copy of the data
df <- copy(data_channel)

# Create new variable channel_level using data.table
df[, channel_level := case_when(
  str_sub(channel_code_unique, -3) == "0000" | channel_code_unique == 51000 ~ 1,
  str_sub(channel_code_unique, -3) == "000" ~ 2,
  str_sub(channel_code_unique, -1) != 0 ~ 3
)]

# Relocate channel_level before channel_parent_code
df = df |> relocate(channel_level, .before = channel_parent_code)

# Sample and display data
df |> 
  dplyr::select(channel_level, channel_parent_code, channel_code_unique, channel_name) |> 
  filter(!is.na((channel_level))) |> 
  slice_sample(n = 10, by = channel_level) |> 
  gt()

# Update data_channel
channel_level <- copy(df)
```

### Time consistency

The channel of delivery became an *optional* reporting item on the new CRS++ reporting scheme in 2004 ([@dietrich2013]).

Information on delivery channels has been added and updated over time. Similarly, new implementing agencies have also been added, while others have seen there name and/or channel code revised. So implementing agencies may be coded and/or described differently across time and space within the dataset.

For consistency, I apply the latest code and name list provided by the OECD (last updated in July 2023)[^1].

[^1]: The Excel file can be found [here](https://www.oecd.org/dac/financing-sustainable-development/development-finance-standards/dacandcrscodelists.htm).

```{r data_channel_code}

# import info from the crs code list
delivery_crs_code <- read_xlsx(
# modify path accordingly  
  path = "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\source\\outcome\\DAC-CRS-CODES.xlsx",
  sheet = "Channel code",
  skip = 6) |>
# clean column names  
  janitor::clean_names() |>
  mutate_if(is.character, 
    .funs = ~ str_squish(str_to_title(.))
  ) |>
  select(channel_parent_code_2024 = channel_parent_category, 
         channel_code_2024 = channel_id, 
         channel_name_2024 = full_name_english)

# copy
df <- channel_level

# merge w/ data set
data_channel_code <- left_join(df, delivery_crs_code,
                           by = c('channel_code_unique' = 'channel_code_2024')) |>
  relocate(channel_parent_code_2024, .after = channel_parent_code) |> 
  relocate(channel_name_2024, .after = channel_name)

# Sample
data_channel_code |> 
  dplyr::select(channel_name, channel_name_2024, 
                channel_parent_code, channel_parent_code_2024) |> 
  slice_sample(n = 10) |> 
  gt()
```

I create two new binary variables for State and non-State channel categories.

> To do: create additional binary variables for channels sub-categories.

```{r channel_state}

# define categories
channel_state = c(10000:12000)
channel_nonstate = c(20000:63000)
# channel_nonstate_ngo = c(20000:23000, 51000)
# channel_nonstate_multi = c(40000:47000)
# channel_nonstate_priv = c(30000:32000, 60000:63000)
# channel_other = 90000

# copy
df <- data_channel_code

# create variable
data_channel <- df |> 
  mutate(
    channel_state = fct(case_when(
      channel_parent_code_2024 %in% channel_state ~"State",
      channel_parent_code_2024 %in% channel_nonstate ~"non-State",
      .default = "Other"
    ))) |> 
  relocate(channel_state, .after = channel_name_2024)

```

> To do (1): create multinomial channel variable.

> To do (2): further data cleaning to reduce missingness.

## Co-operation modalities

```{r data_mod}

# define categories
debt = c('F01')
budget = c('A01', 'A02')
core = c('B01', 'B02')
pooled = c('B03', 'B031', 'B032', 'B033', 'B04')
project = c('C01', 'D02')

# copy
df <- data_channel

# create variable
data_mod <- df |> 
  mutate(flow_modality = fct(case_when(
    aid_t %in% debt ~ "Debt relief",
    aid_t %in% budget ~ "Budget support",
    aid_t %in% core ~ "Core contributions",
    aid_t %in% pooled ~ "Pooled funding",
    aid_t %in% project ~ "Project-type interventions and Other technical assistance"
  ))) |> 
  relocate(flow_modality, .after = aid_t)
```

## Sectors

```{r data_sector}

# define categories
humanitarian = c(72010:74020)
development = c(11110:60063)
  sectoral = c(11110:43082)
    infra = c(11110:25040)
      infra_social = c(11110:16080)
      infra_eco = c(21010:25040)
    prod = c(31110:43082)
  budget = 51010
  inkind = c(52010:53040)
  debt = c(60010:60063)

# copy
df <- data_mod
  
# create variables
data_sector <- df |> 
  mutate(
    sector_hum = fct(case_when(
      purpose_code %in% humanitarian ~ "Humanitarian",
      purpose_code %in% development ~ "Development",
      .default = "Other"
  )),
    sector_multi = fct(case_when(
      purpose_code %in% humanitarian ~ "Humanitarian",
      purpose_code %in% sectoral ~ "Development (sectoral)",
      purpose_code %in% budget ~ "Budget support",
      purpose_code %in% debt ~ "Debt relief",
      ))) |> 
  relocate(sector_hum:sector_multi, .after = aid_t)
```

## Save

```{r}

# copy
data_crs <- data_sector

# save
save(data_crs, delivery_crs_code,
     file = "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_crs.RData")

# remove
rm(list = ls())
```
