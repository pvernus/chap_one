---
title: "Data: Outcome"
format: html
editor: visual
---

# Outcome

```{r load}

# load packages
source(here::here('scripts', 'library.R')) 

# load data 
# change path accordingly 
load("C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_crs.RData")
```

## Quantity

+ Commitments in constant dollars

+ Share of total commitments (%)

> **To do**: consider disbursements.

### Missing

```{r}

## missing

# modality

data_crs |> 
#  filter(sector_code!=600) |>  
  group_by(year) |> 
  summarize(
    total_amount = sum(usd_commitment_defl, na.rm = T),
    na_amount = sum(usd_commitment_defl[is.na(flow_modality)], na.rm = T)
    ) |> 
  mutate(share_of_total = round(na_amount / total_amount * 100, 2))

data_crs |> 
  filter(year %in% c(2005:2009) & is.na(flow_modality)) |> 
  filter(sector_code!=600) |> 
  arrange(desc(usd_commitment_defl))

data_crs |> 
  filter(year %in% c(2005:2009) & is.na(flow_modality)) |> 
  filter(sector_code!=600) |> 
  group_by(donor_name, recipient_name) |> 
  summarize(total = sum(usd_commitment_defl, na.rm = T)) |> 
  arrange(desc(total))

# channel

data_crs |> 
  filter(sector_code!=600) |>  
  group_by(year) |> 
  summarize(
    total_amount = sum(usd_commitment_defl, na.rm = T),
    na_amount = sum(usd_commitment_defl[is.na(channel_name_2024)], na.rm = T)) |> 
  mutate(share_of_total = round(na_amount / total_amount * 100, 2))

data_crs |> 
  filter(sector_code!=600) |>
  filter(year %in% c(2005:2009) & is.na(channel_name_2024)) |> 
  arrange(desc(usd_commitment_defl))
```

```{r}

data_crs |> 
  group_by(flow_modality, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, .by = flow_modality) |> 
  arrange(flow_modality)

## sector (bi)
# modality
data_crs |> 
  group_by(sector_hum, flow_modality) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, 
         .by = sector_hum) |> 
  arrange(sector_hum)
# channel
data_crs |> 
  group_by(sector_hum, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, 
         .by = sector_hum) |> 
  arrange(sector_hum)

## sector (multi)
# modality
data_crs |> 
  group_by(sector_multi, flow_modality) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  ungroup() |> 
  group_by(sector_multi) |> 
  mutate(share_of_total = round(total_amount / sum(total_amount) * 100, 2)) |> 
  arrange(sector_multi, desc(share_of_total))
# channel
data_crs |> 
  group_by(sector_multi, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  ungroup() |> 
  group_by(sector_multi) |> 
  mutate(share_of_total = round(total_amount / sum(total_amount) * 100, 2)) |> 
  arrange(sector_multi, desc(share_of_total))
```

> **To do (1)**: cross-tables channels, modalities, and sectors + type of flow.

> **To do (2)**: add new variable sector_main_code.

## Unit of observation

### Donor-Recipient pairs

Following Faye and Niehaus (2012) and Arezki et al. (2025), I adopt a dyadic approach.

**Advantages**

+ more credible counterfactual. Following a shock, changes in flows received by a recipient can be due to changes in flow from a specific donor or changes in the composition of the pool of donors. remove the risk of composition effect at the donor level (however, it remains at the sector level).

+ allows to distinguish between the effect's extensive vs. intensive margins.

+ allows us to look at the effects of interference (i) between donors, within a recipient country, and (ii) between recipients, within a donor's portfolio.

**Disadvantages**

+ higher risk of measurement error. However, I don't see any systematic bias one way or the other, but this can create noise in the estimation of treatment effects.

+ Faye and Niehaus (2012) and Arezki et al. (2025) don't include multilateral donors, for different reasons. However, I don't see real restriction on including them in the analysis if I use dyad-level FEs.

```{r}
# donors 
length(unique(data_crs$donor_id))
# recipients
length(unique(data_crs$recipient_id))
# pairs
length(unique(data_crs$donor_id)) * length(unique(data_crs$recipient_id))
```

## Sample

```{r data_sample}

data_sample <- data_crs
```

+ **Unit of observation**

```{r unit_outcome}

# define the unit of observation
unit_outcome <- data_sample |> 
  expand(nesting(donor_id, donor_name, cohort_donor), # donor
         nesting(recipient_id, recipient_name, cohort_recipient), # recipient
         year) # year
```

+ **Quantity**

```{r quantity_outcome}

## define the unit-specific quantity
quantity_outcome <- data_sample |> 
  summarize(
# total  
  commit_total = sum(usd_commitment_defl, na.rm = T),
# channels of delivery 
  commit_nonstate = sum(usd_commitment_defl[channel_nonstate==1], na.rm = T),
# co-operation modalities
  commit_budg = sum(usd_commitment_defl[grepl("^A0", aid_t)], na.rm = T),
  commit_proj = sum(usd_commitment_defl[aid_t=="C01|D02"], na.rm = T), 
# flow types
  commit_grant = sum(usd_commitment_defl[flow_code==11], na.rm = T),
  commit_loan = sum(usd_commitment_defl[flow_code==13], na.rm = T), 
.by = c(donor_id, recipient_id, year)
)
```

+ **Merge**

```{r outcome}

## merge outcome data
outcome <- merge(unit_outcome, quantity_outcome, 
                 by=c("donor_id", "recipient_id", "year"), all.x = TRUE) |> 
# treat "true" zeros: NA if country's registration in OECD CRS > current period
  mutate(across(starts_with("commit_"), ~ ifelse(
    is.na(.x) & (cohort_donor <= year | cohort_recipient <= year), 0, .x)))
```

> **To do**: consider alternative definitions of nonzero outcomes, based on (i) rounding (ex: at 0.001 MUSD unit) and (ii) by including a threshold (ex: >= 1 000 USD).

+ **ISO codes**

```{r iso}

# add new variable
outcome$iso3c <- countrycode(sourcevar = outcome[, "recipient_name"], 
                             origin = "country.name", destination = "iso3c", warn = T) 
# some values were not matched unambiguously: Kosovo, Micronesia 
outcome <- outcome |> 
  mutate(iso3c = case_when( 
    recipient_name=="Micronesia" ~ "FSM",
    recipient_name=="Kosovo" ~ "XXK", 
    .default = iso3c )
    ) |> 
  relocate(iso3c, .after = recipient_name)
```

+ **Duplicates**

```{r outcome_dupes}

janitor::get_dupes(outcome, donor_id, recipient_id, year)
```

# Appendix

+ List of donors

+ List of recipients

+ Waffle plot with entry/exit of donors and recipients

+ Table with Total commitments (%) per (i) donor and (ii) recipient

# Save

```{r}

# save
save(outcome, 
     file =  "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_outcome.RData")

# remove
rm(list = ls())
```