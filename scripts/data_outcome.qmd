---
title: "Data: Outcome"
format: html
editor: visual
---

# Outcome

```{r load}

# load packages
source(here::here('scripts', 'library.R')) 

# load data 
# change path accordingly 
load("C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_crs.RData")
```

## Quantity

-   Commitments in constant dollars

-   Share of total commitments (%)

> **To do**: consider disbursements.

### Missing

#### Modality

```{r na_modality}

# share commitments w/ missing modality by year
data_crs |> 
  group_by(year) |> 
  summarize(
    total_amount = sum(usd_commitment_defl, na.rm = T),
    na_amount = sum(usd_commitment_defl[is.na(aid_t)], na.rm = T),
    other_amount = sum(usd_commitment_defl[flow_modality=='Other'], na.rm = T)
    ) |> 
  mutate(
    share_na = round(na_amount / total_amount * 100, 2),
    share_other = round(other_amount / total_amount * 100, 2)
    )
```

#### Channel

```{r na_channel}

# by year
data_crs |> 
  group_by(year) |> 
  summarize(
    total_amount = sum(usd_commitment_defl, na.rm = T),
    na_amount = sum(usd_commitment_defl[is.na(channel_code_unique)], na.rm = T)) |> 
  mutate(share_na = round(na_amount / total_amount * 100, 2))

# NOTE: missing data concentrate between 2004 and 2007  

# focus on missing data between 2004:2007
# group by purpose
data_crs |> 
  filter(year %in% c(2004:2007), is.na(channel_code_unique)) |> 
  summarize(n = sum(usd_commitment_defl, na.rm = T), .by = c(purpose_code, purpose_name)) |> 
  mutate(total = sum(n)) |>
  mutate(share = round(n / total * 100, 2)) |>
  arrange(desc(n))

# NOTE: (following data imputation related to debt forgiveness) no clear sectoral concentration of missing data

# group by recipient
data_crs |> 
  filter(year %in% c(2004:2007), is.na(channel_code_unique)) |> 
  summarize(n = sum(usd_commitment_defl, na.rm = T), .by = recipient_name) |> 
  mutate(total = sum(n)) |>
  mutate(share = round(n / total * 100, 2)) |>
  arrange(desc(n))

# NOTE: Top 3 country (India, Nigeria, Pakistan) = 1/4 of NAs

# by purpose and recipient
data_crs |> 
  filter(year %in% c(2004:2007), is.na(channel_code_unique)) |> 
  summarize(n = sum(usd_commitment_defl, na.rm = T), .by = c(purpose_name, recipient_name)) |> 
  mutate(total = sum(n)) |>
  mutate(share = round(n / total * 100, 2)) |>
  arrange(desc(n))

# NOTE: Top 3 (Debt buy-back in	Nigeria, Road transport	in India, Primary education	in West Bank and Gaza Strip) = 7% of NAs

```

### Cross-tables

```{r cross-table}

data_crs |> 
  group_by(flow_modality, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, .by = flow_modality) |> 
  arrange(flow_modality, desc(share_of_total))

## sector (bi)
# modality
data_crs |> 
  group_by(sector_hum, flow_modality) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, 
         .by = sector_hum) |> 
  arrange(sector_hum, desc(share_of_total))
# channel
data_crs |> 
  group_by(sector_hum, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, 
         .by = sector_hum) |> 
  arrange(sector_hum, desc(share_of_total))

## sector (multi)
# modality
data_crs |> 
  group_by(sector_multi, flow_modality) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  ungroup() |> 
  group_by(sector_multi) |> 
  mutate(share_of_total = round(total_amount / sum(total_amount) * 100, 2)) |> 
  arrange(sector_multi, desc(share_of_total))
# channel
data_crs |> 
  group_by(sector_multi, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  ungroup() |> 
  group_by(sector_multi) |> 
  mutate(share_of_total = round(total_amount / sum(total_amount) * 100, 2)) |> 
  arrange(sector_multi, desc(share_of_total))
```

> **To do (1)**: cross-tables channels, modalities, and sectors + type of flow.

```{r}

prop(xtabs(
  usd_commitment_defl ~ flow_modality + channel_state,
  data = data_crs,
  na.action = na.omit
))

prop(xtabs(
  usd_disbursement_defl ~ flow_modality + channel_state,
  data = data_crs,
  na.action = na.omit
))
```

## Variables

-   **Quantity**

```{r quantity}

## define the unit-specific quantity
quantity_outcome <- data_crs |> 
# commitments in constant USD  
  summarize(
  # total  
    commit_total = sum(usd_commitment_defl, na.rm = T),
  # co-operation modalities
    commit_budg = sum(usd_commitment_defl[as.integer(flow_modality)==1], na.rm = T),
    commit_proj = sum(usd_commitment_defl[as.integer(flow_modality)==2], na.rm = T),   
  # channels of delivery 
    commit_state = sum(usd_commitment_defl[as.integer(channel_state)==1], na.rm = T),
    commit_nonstate = sum(usd_commitment_defl[as.integer(channel_state)==2], na.rm = T),
.by = c(donor_id, recipient_id, year)
) |> 
# proportions of total commitments in constant USD  
  mutate(
  # co-operation modalities
    sh_budg = ifelse(commit_total>0, commit_budg/commit_total, 0),
    sh_proj =  ifelse(commit_total>0, commit_proj/commit_total, 0),
  # channels of delivery 
    sh_state = ifelse(commit_total>0, commit_state/commit_total, 0),
    sh_nonstate = ifelse(commit_total>0, commit_nonstate/commit_total, 0),
  )
```

```{r quantity_outcome_hum}

## define the unit-specific quantity
quantity_outcome_hum <- data_crs |> 
# commitments in constant USD  
  summarize(
  # total  
    commit_total = sum(usd_commitment_defl, na.rm = T),
  # co-operation modalities
    commit_budg = sum(usd_commitment_defl[as.integer(flow_modality)==1], na.rm = T),
    commit_proj = sum(usd_commitment_defl[as.integer(flow_modality)==2], na.rm = T),   
  # channels of delivery 
    commit_state = sum(usd_commitment_defl[as.integer(channel_state)==1], na.rm = T),
    commit_nonstate = sum(usd_commitment_defl[as.integer(channel_state)==2], na.rm = T),
.by = c(donor_id, recipient_id, sector_hum, year)
) |> 
# proportions of total commitments in constant USD  
  mutate(
  # co-operation modalities
    sh_budg = ifelse(commit_total>0, commit_budg/commit_total, 0),
    sh_proj =  ifelse(commit_total>0, commit_proj/commit_total, 0),
  # channels of delivery 
    sh_state = ifelse(commit_total>0, commit_state/commit_total, 0),
    sh_nonstate = ifelse(commit_total>0, commit_nonstate/commit_total, 0),
  ) |> 
  arrange(donor_id, recipient_id)
```

> For the proportions, how to deal with negative commitments? 

## Units of observation

```{r data_unit_outcome}

load(file = "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_unit.RData")
```

Following Faye and Niehaus (2012) and Arezki et al. (2025), I adopt a dyadic approach in a panel setting.

**Advantages**

-   more credible counterfactual. Following a shock, changes in flows received by a recipient can be due to changes in flow from a specific donor or changes in the composition of the pool of donors. remove the risk of composition effect at the donor level (however, it remains at the sector level).

-   allows to distinguish between the effect's extensive vs. intensive margins.

-   allows us to look at the effects of interference (i) between donors, within a recipient country, and (ii) between recipients, within a donor's portfolio.

**Disadvantages**

-   higher risk of measurement error. However, I don't see any systematic bias one way or the other, but this can create noise in the estimation of treatment effects.

-   Faye and Niehaus (2012) and Arezki et al. (2025) don't include multilateral donors, for different reasons. However, I don't see real restriction on including them in the analysis if I use dyad-level FEs.

```{r}
# donors 
length(unique(data_crs$donor_id))
# recipients
length(unique(data_crs$recipient_id))
# pairs
length(unique(data_crs$donor_id)) * length(unique(data_crs$recipient_id))
# years

# total number of observations
length(unique(data_crs$donor_id)) * length(unique(data_crs$recipient_id)) * length(unique(data_crs$year))
```

## Outcome sample

-   **Merge**

```{r outcome}

## merge outcome data
data_outcome <- merge(data_unit, quantity_outcome, 
                 by=c("donor_id", "recipient_id", "year"), all.x = TRUE) |> 
# treat "true" zeros: NA if country's registration in OECD CRS > current period
  mutate(across(starts_with("commit_"), ~ ifelse(
    is.na(.x) & (cohort_donor <= year | cohort_recipient <= year), 0, .x)))
```

```{r outcome_hum}

## merge outcome data
data_outcome_hum <- merge(data_unit_hum, quantity_outcome_hum, 
                 by=c("donor_id", "recipient_id", "sector_hum", "year"), all.x = TRUE) |> 
# treat "true" zeros: NA if country's registration in OECD CRS > current period
  mutate(across(starts_with("commit_"), ~ ifelse(
    is.na(.x) & (cohort_donor <= year | cohort_recipient <= year), 0, .x)))
```

> **To do**: consider alternative definitions of nonzero outcomes, based on (i) rounding (ex: at 0.001 MUSD unit) and (ii) by including a threshold (ex: \>= 1 000 USD).

-   **Duplicates**

```{r outcome_dupes}

janitor::get_dupes(data_outcome, donor_id, recipient_id, year)
janitor::get_dupes(data_outcome_hum, donor_id, recipient_id, sector_hum, year)
```

# Appendix

-   List of donors

-   List of recipients

-   Waffle plot with entry/exit of donors and recipients

-   Table with Total commitments (%) per (i) donor and (ii) recipient

# Save

```{r data_outcome}

# save
save(data_outcome, data_outcome_hum,
     file =  "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_outcome.RData")
```

```{r}
# remove all objects in the environment
# rm(list = ls())
```

