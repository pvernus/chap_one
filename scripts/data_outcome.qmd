---
title: "Data: Outcome"
format: html
editor: visual
---

# Outcome

```{r load}

# load packages
source(here::here('scripts', 'library.R')) 

# load data 
# change path accordingly 
load("C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_crs.RData")
```

## Quantity

-   Commitments in constant dollars

-   Share of total commitments (%)

> **To do**: consider disbursements.

### Missing

#### Modality

```{r na_modality}

# share commitments w/ missing modality by year
data_crs |> 
#  filter(sector_code!=600) |>  
  group_by(year) |> 
  summarize(
    total_amount = sum(usd_commitment_defl, na.rm = T),
    na_amount = sum(usd_commitment_defl[flow_modality=='Other'], na.rm = T)
    ) |> 
  mutate(share_of_total = round(na_amount / total_amount * 100, 2))

# focus on 
# years with high missing values
# obs. with no modality
data_crs |> 
  filter(year %in% c(2005:2009), flow_modality=='Other', is.na(aid_t)) |> 
  arrange(desc(usd_commitment_defl))

# focus on
# main dyads with missing values
data_crs |> 
  filter(year %in% c(2005:2009), flow_modality=='Other', is.na(aid_t)) |> 
  group_by(donor_name, recipient_name) |> 
  summarize(total = sum(usd_commitment_defl, na.rm = T)) |> 
  arrange(desc(total))
```

#### Channel

```{r na_channel}

# by year
data_crs |> 
  group_by(year) |> 
  summarize(
    total_amount = sum(usd_commitment_defl, na.rm = T),
    na_amount = sum(usd_commitment_defl[is.na(channel_code_unique)], na.rm = T)) |> 
  mutate(share_of_total = round(na_amount / total_amount * 100, 2))

# NOTE: missing data concentrate between 2005 and 2007  

# focus on missing data between 2005:2007
# group by purpose
data_crs |> 
  filter(year %in% c(2005:2007), is.na(channel_name_2024)) |> 
  summarize(n = sum(usd_commitment_defl, na.rm = T), .by = purpose_name) |> 
  mutate(total = sum(n)) |>
  mutate(share = round(n / total * 100, 2)) |>
  arrange(desc(n))

# NOTE: almost a quarter of missing data between 2005:2007 is debt forgiveness
# Potential imputation rule: assign missing data with debt forgiveness purpose to State channels

# group by recipient
data_crs |> 
  filter(year %in% c(2005:2007), is.na(channel_name_2024)) |> 
  summarize(n = sum(usd_commitment_defl, na.rm = T), .by = recipient_name) |> 
  mutate(total = sum(n)) |>
  mutate(share = round(n / total * 100, 2)) |>
  arrange(desc(n))

# NOTE: one quarter of missing data between 2005:2007 occurs in three countries: Nigeria, Iraq, India

# by purpose and recipient
data_crs |> 
  filter(year %in% c(2005:2007), is.na(channel_name_2024)) |> 
  summarize(n = sum(usd_commitment_defl, na.rm = T), .by = c(purpose_name, recipient_name)) |> 
  mutate(total = sum(n)) |>
  mutate(share = round(n / total * 100, 2)) |>
  arrange(desc(n))

# NOTE: 16% of missing data between 2005:2007 is due to debt forgiveness in Nigeria and Irak

```


```{r}

data_crs |> 
  group_by(flow_modality, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, .by = flow_modality) |> 
  arrange(flow_modality)

## sector (bi)
# modality
data_crs |> 
  group_by(sector_hum, flow_modality) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, 
         .by = sector_hum) |> 
  arrange(sector_hum)
# channel
data_crs |> 
  group_by(sector_hum, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  mutate(share_of_total = total_amount / sum(total_amount) * 100, 
         .by = sector_hum) |> 
  arrange(sector_hum)

## sector (multi)
# modality
data_crs |> 
  group_by(sector_multi, flow_modality) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  ungroup() |> 
  group_by(sector_multi) |> 
  mutate(share_of_total = round(total_amount / sum(total_amount) * 100, 2)) |> 
  arrange(sector_multi, desc(share_of_total))
# channel
data_crs |> 
  group_by(sector_multi, channel_state) |> 
  summarize(total_amount = sum(usd_commitment_defl, na.rm = T), .groups = 'drop') |> 
  ungroup() |> 
  group_by(sector_multi) |> 
  mutate(share_of_total = round(total_amount / sum(total_amount) * 100, 2)) |> 
  arrange(sector_multi, desc(share_of_total))
```

> **To do (1)**: cross-tables channels, modalities, and sectors + type of flow.

## Unit of observation

### Donor-Recipient pairs

Following Faye and Niehaus (2012) and Arezki et al. (2025), I adopt a dyadic approach in a panel setting.

**Advantages**

-   more credible counterfactual. Following a shock, changes in flows received by a recipient can be due to changes in flow from a specific donor or changes in the composition of the pool of donors. remove the risk of composition effect at the donor level (however, it remains at the sector level).

-   allows to distinguish between the effect's extensive vs. intensive margins.

-   allows us to look at the effects of interference (i) between donors, within a recipient country, and (ii) between recipients, within a donor's portfolio.

**Disadvantages**

-   higher risk of measurement error. However, I don't see any systematic bias one way or the other, but this can create noise in the estimation of treatment effects.

-   Faye and Niehaus (2012) and Arezki et al. (2025) don't include multilateral donors, for different reasons. However, I don't see real restriction on including them in the analysis if I use dyad-level FEs.

```{r}
# donors 
length(unique(data_crs$donor_id))
# recipients
length(unique(data_crs$recipient_id))
# pairs
length(unique(data_crs$donor_id)) * length(unique(data_crs$recipient_id))
# years

# total number of observations
length(unique(data_crs$donor_id)) * length(unique(data_crs$recipient_id)) * length(unique(data_crs$year))
```

## Sample

```{r data_sample}

data_sample <- copy(data_crs)
```

-   **Unit of observation**

```{r data_unit_outcome}

load(file = "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_unit_outcome.RData")
```

-   **Quantity**

```{r quantity_outcome}

## define the unit-specific quantity
quantity_outcome <- data_sample |> 
# commitments in constant USD  
  summarize(
  # total  
    commit_total = sum(usd_commitment_defl, na.rm = T),
  # co-operation modalities
    commit_budg = sum(usd_commitment_defl[grepl("^A0", aid_t)], na.rm = T),
    commit_proj = sum(usd_commitment_defl[aid_t=="C01|D02"], na.rm = T),   
  # channels of delivery 
    commit_state = sum(usd_commitment_defl[channel_nonstate==0], na.rm = T),
    commit_nonstate = sum(usd_commitment_defl[channel_nonstate==1], na.rm = T),
.by = c(donor_id, recipient_id, year)
) |> 
# proportions of total commitments in constant USD  
  mutate(
  # co-operation modalities
    sh_budg = commit_budg / commit_total,
    sh_proj =  commit_proj / commit_total,
  # channels of delivery 
    sh_state =  commit_state / commit_total,
    sh_nonstate =  commit_nonstate / commit_total,
  )
```

-   **Merge**

```{r outcome}

## merge outcome data
outcome <- merge(unit_outcome, quantity_outcome, 
                 by=c("donor_id", "recipient_id", "year"), all.x = TRUE) |> 
# treat "true" zeros: NA if country's registration in OECD CRS > current period
  mutate(across(starts_with("commit_"), ~ ifelse(
    is.na(.x) & (cohort_donor <= year | cohort_recipient <= year), 0, .x)))
```

> **To do**: consider alternative definitions of nonzero outcomes, based on (i) rounding (ex: at 0.001 MUSD unit) and (ii) by including a threshold (ex: \>= 1 000 USD).

-   **Duplicates**

```{r outcome_dupes}

janitor::get_dupes(outcome, donor_id, recipient_id, year)
```

# Appendix

-   List of donors

-   List of recipients

-   Waffle plot with entry/exit of donors and recipients

-   Table with Total commitments (%) per (i) donor and (ii) recipient

# Save

```{r}

# save
save(outcome, 
     file =  "C:\\Users\\pauvernu\\Seafile\\library\\chap_one_data\\data\\outcome\\data_outcome.RData")

# remove
rm(list = ls())
```
